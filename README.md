# Dockerfiles

[![Build Status](https://travis-ci.org/ahawker/dockerfiles.svg?branch=master)](https://travis-ci.org/ahawker/dockerfiles)

Build a common set of images from Dockerfiles.

## Status

This is under active development but the core functionality should be in place.

## Goals

Automate the process of building structured images from Dockerfiles that are tagged/linked together.

## Related

See [Dotfiles](https://github.com/ahawker/dotfiles) for bringing these into your shell environment.

## Usage

### End User

If you're an end user, you should consume the images from the configured image registry that are uploaded there as part of the CI/CD process.

By default, these are located [here](https://hub.docker.com/u/ahawker/) on `Dockerhub` and are deployed automatically via [Travis CI](https://travis-ci.org/ahawker/dockerfiles).

### Development

If you're a developer working on this repository, here's some hints to hopefully guide you through the process.

**Usage**

All `Makefile` should support `make help` to display their usage with `help` being the default goal if unspecified.

```bash
$ make
all                            Run recursive 'make all' to build and deploy all images.
build                          Run recursive 'make build' to build all images.
deploy                         Run recursive 'make deploy' to deploy all images.
clean                          Run recursive 'make clean' to clean all image directories.
help                           Print Makefile usage.
```

While not visible in the `help` output, the main `Makefile` supports recursive target generation. This enables invoking targets on the `Makefile` defined in subdirectories.

For example, let's access the `alpine` image.

```bash
$ make alpine
all                            Build and deploy image created from Dockerfile.
build                          Build image from Dockerfile.
clean                          Clean state generated by previous images built from Dockerfile.
deploy                         Deploy image built from Dockerfile.
help                           Print Makefile usage.
```

That's just the default target, `help`. Let's specify one by invoking the `build` target for the `alpine` image.

```bash
make alpine-build
[TRACE] - [root] - Running 'build' for child image 'alpine'
[TRACE] - [alpine] - Running 'build'
Sending build context to Docker daemon  9.216kB
...
...
Successfully built 57642cb07bbe
Successfully tagged ahawker/alpine:6cdaa04-1531262409-2704231498
Successfully tagged ahawker/alpine:latest
[TRACE] - [alpine] - Completed 'build'
[TRACE] - [root] - Completed 'build' for child image 'alpine'
```

The recursive targets following the `<directory-name>-<target-name>` pattern. Building the `alpine` image is the `alpine-build` target while deploying it is `alpine-deploy`. This pattern holds for all subdirectories, including nested ones.

For example, let's build a specific ruby image that is multiple directories down.

```bash
$ make ruby/2.4-build
[TRACE] - [root] - Running 'build' for child image 'ruby/2.4'
[TRACE] - [ruby2.4] - Running 'build' for base image 'alpine'
[TRACE] - [alpine] - Running 'build'
Sending build context to Docker daemon  8.192kB
...
...
Successfully built cfe5967be297
Successfully tagged ahawker/ruby2.4:6cdaa04-1531262629-3151336003
Successfully tagged ahawker/ruby2.4:2.5.1
Successfully tagged ahawker/ruby2.4:latest
[TRACE] - [ruby2.4] - Completed 'build'
[TRACE] - [root] - Completed 'build' for child image 'ruby/2.4'
```

## Troubleshooting

This repository uses `make` as the build system. If you're not familiar with it, debugging what's happening behind the scenes can sometimes feel like dark magic. Without opening a too large can of worms, let's walk through some of the common issues I might expect one to encounter while developing within this repository.

### A build command failed with: "manifest for XYZ not found"

**Example:**

```bash
$ make ruby/2.4-build
[TRACE] - [root] - Running 'build' for child image 'ruby/2.4'
[TRACE] - [ruby2.4] - Running 'build' for base image 'alpine'
[TRACE] - [ruby2.4] - Completed 'build' for base image 'alpine'
[TRACE] - [ruby2.4] - Running 'build'
Sending build context to Docker daemon  11.78kB
Step 1/21 : ARG REPO
Step 2/21 : ARG BASE_IMAGE
Step 3/21 : ARG TAG=latest
Step 4/21 : FROM $REPO/$BASE_IMAGE:$TAG
manifest for ahawker/alpine:6cdaa04-1531262592-835582456 not found
make[1]: *** [build] Error 1
make: *** [ruby/2.4-build] Error 2
```

**Context:**

When any `make` command is invoked, a number of runtime defined parameters are set within the root `Makefile`. The two major ones to consider are `BUILD_ID` and `BUILD_TS`. If not specified by the build environment, these will be set to a random identifier and the current timestamp epoch respectively. These values, along with the `git` hash will be used to `tag` every image build in the current process execution.

**Issue:**

This happens when you build a base image e.g. `alpine` in one process execution and then attempt to build a image that depends on `alpine` in a new process execution.

**Solution:**

Run a `clean` command against the image you're currently trying to build e.g. `make terraform-clean`. If you're trying to rebuild _all_ images, run `make clean`.

### A command failed with: "Required variable XYZ not set"

**Example:**

```bash
$ make build
[TRACE] - [ruby] - Running 'build' for child image '2.4'
Required variable "REPO" not set
make[1]: *** [requires-REPO] Error 1
make: *** [2.4-build] Error 2
```

**Context:**

Each `Makefile` performs validation on the build context to make sure all necessary values are set (or loaded from `.env`) into the `make` context before executing the corresponding `docker [build|deploy]` command.

**Issue:**

One of the variables defined in a `requires-XYZ` target dependency is not set/empty.

**Solution:**

A few possibilities:

* You've defined a `requires-XYZ` in your `Makefile` but it is not yet defined in your `.env` file. Define it!
* You're running the `Makefile` directly in a subdirectory. This is not currently supported and all images can/should be possible to build from the root `Makefile`.

## Contributing

Adding a new `Dockerfile` to this repo requires an understanding of how the build process works. For building an image from a `Dockerfile`, the build process requires the following:

### Dockerfile

This is just a standard [Dockerfile](https://docs.docker.com/engine/reference/builder/). At a minimum, this should be parameterized with `ARG` instructions for specifying the base image repository, image name and tag. This commonly appears as:

```docker
ARG REPO
ARG BASE_IMAGE
ARG TAG=latest

FROM $REPO/$BASE_IMAGE:$TAG
```

This allows the `Dockerfile` to build off the most recent version of the `BASE_IMAGE` that was created as part of the current build process.

#### Best Practices

It is highly recommended to use `ARG` instructions to parameterize as much of the `Dockerfile` as possible. These values can be injected during the `docker build` process and can be defined in a set of `.env` files. This allows for potential reuse of the `Dockerfile`/`Makefile` combination with any number of `.env` files.

### Makefile

This is just a standard `Makefile` for GNU Make. At a minimum, it needs to define the following targets:

* `all` - Invokes the `build` and then subsequent `deploy` target.
* `build` - Builds a image by injecting build arguments into `docker build` for the local `Dockerfile`.
* `clean` - Cleans up any state created by previous builds, including images stored by the `Docker` daemon.
* `deploy` - Pushes tagged versions of the locally built image to a remote repository.

Beyond defining these targets, the `Makefile` is responsible for the following items:

#### Validation

Validation of build arguments before invoking the `build` and `deploy` targets which call `docker build` and `docker push` respectively. This commonly appears as:

```make
.PHONY: all-requirements
all-requirements: build-requirements deploy-requirements

.PHONY: build-requirements
build-requirements: requires-REPO \
    requires-TAG \
    requires-IMAGE \
    requires-BASE_IMAGE \
    requires-SOME_VARIABLE_IN_ENV_FILE

.PHONY: deploy-requirements
deploy-requirements: requires-REPO \
    requires-TAG \
    requires-IMAGE

requires-%:
    @if [ -z '${${*}}' ]; then echo 'Required variable "$*" not set' && exit 1; fi
```

#### Loading Optional .env Files

If a `.env` file is located within the directory, the `Makefile` is responsible for loading it into the `make` context. Once loaded, these values can be passed in as arguments to the `docker build` command. This commonly appears as:

```make
ENVFILE ?= .env
ifneq ($(strip $(wildcard $(ENVFILE))),)
	include $(ENVFILE)
	export $(shell sed 's/=.*//' $(ENVFILE))
endif
```

#### Dependency Detection

If the `Dockerfile` has a base image dependency that is part of this repository, it is the responsiblity of this `Makefile` to detect the location of the base image and create a phony target dependency on it. This commonly appears as:

**Create dependencies based on files within image directory**

```make
BUILD_DEPS := $(shell find . -type f \( -iname '*' ! -iname '*build' \))

build: $(BUILD_DEPS)
    ...
```

**Detect base image and create target for invoking actions against it**

```make
BASE_IMAGE_DEPS := $(shell grep -ril "^IMAGE=$(BASE_IMAGE)" $(DOCKERFILES_DIR) | xargs dirname)

$(BASE_IMAGE)-%:
	@$(MAKE) -C $(BASE_IMAGE_DEPS) $*
```

**Add base image and files as target dependencies**

```make
build: $(BASE_IMAGE)-build $(BUILD_DEPS) | build-requirements
    ...

clean: $(BASE_IMAGE)-clean | clean-requirements

.PHONY: deploy
deploy: build $(BASE_IMAGE)-deploy | deploy-requirements
    ...
```

#### Best Practices

It is highly recommend to define the phony `help` target and set this as the default, enabling users to see supported commands/usage prior to execution. This commonly appears as:

```make
.DEFAULT_GOAL := help

.PHONY: help
help: ## Print Makefile usage.
    @awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)
```

## .env Files

An optional `.env` file can be placed in the directory with the `Dockerfile` and `Makefile` to define values for build arguments. This commonly appears as:

```make
# Name of the image created from the Dockerfile.
IMAGE=foobar

# Name of the base image to build on.
BASE_IMAGE=foobar-base

# Version of some package.
PACKAGE_VERSION=1.2.3
```

## Open Questions

* How to handle reuse of `Dockerfile`/`Makefile` combinations with multiple .env files? (Many to One)
* How to support a `BASE_IMAGE` that is not locally defined?

## Open Documentation Items

* Nested Images
* How to fork

## License

[Apache 2.0](LICENSE)
